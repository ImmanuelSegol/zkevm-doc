% !TeX spellcheck = en_GB
% !TeX root = ../../build/zkEVM-architecture.tex

\section{Simple Virtual Machine}

\begin{frame}{Main State Machine of a Simplified Virtual Machine}
\begin{figure}
	\includegraphics[width=0.65\textwidth]{\zkevmdir/architecture/figures/main-state-machine-simplified-overview}
\end{figure}
\end{frame}
















\begin{frame}{Example Program}
\begin{itemize}
\item Let's assume we have the following program:
\[
\begin{array}{|c|l|c|}
\hline
\mathbf{Position} & \multicolumn{2}{|c|}{\mathbf{Instruction}} \\ \hline
0 & \mathbf{MOV} & A, 10 \\ \hline
1 & \mathbf{MOV} & B, 3 \\ \hline
2 & \mathbf{JMP}~(if~B = 0) & 6 \\ \hline
3 & \mathbf{MUL} & A, A \\ \hline
4 & \mathbf{DEC} & B \\ \hline
5 & \mathbf{JMP} & 2 \\ \hline
6 & \mathbf{STOP} & \emptyset \\ \hline
\end{array}
\]
\end{itemize}
\end{frame}







%TODO: Do it step by step (limiting only moving one state to another and blabla) and better explanations

%TODO: Generalize it to multiple states in parallel
\begin{frame}[allowframebreaks]{Starting from the Basics: Move State Machine}
\vspace{-0.3cm}
\begin{figure}
	\includegraphics[width=0.8\textwidth]{\zkevmdir/architecture/figures/main-state-machine-2registres}
\end{figure}

\begin{itemize}
\item We have used the following notation:
\begin{enumerate}[a)]
\item \textbf{inX}: $1$ or $0$ depending if the state $X_i$ is included in the sum or not.

\item \textbf{op}: The resulting operation between the included states.

\item \textbf{setX}: $1$ or $0$ depending if one state (or a combination or more) will be moved into $X_{i+1}$.
\end{enumerate}
 
\item The relations between the states of the registries can be expressed as follows:
\begin{align*}
\op_i &= A_i \cdot \inp A_i + B_i \cdot \inp B_i + FREE_i \cdot \inp FREE_i, \\
aux_i &= \op_i +  isM_i \cdot \op_i \cdot (\op_i - 1) \\
A_{i+1} &= \set A_i \cdot (aux_i - A_i) %+ freeload_i \cdot (value - A_i) 
+ A_i - dec_i, \\
B_{i+1} &= \set B_i \cdot (aux_i - B_i) %+ freeload_i \cdot (value - B_i) 
+ B_i - dec_i, \\
PC_{i+1} &= PC_i + 1 + isJMP \cdot (dest - PC_i - 1) + isJMPC \cdot (isSatisfied_i \cdot (dest - PC_i - 1)).
\end{align*}

\item Here:
\begin{enumerate}
\item $FREE$ is the second input passed to the MOV function.
%\item $value$ is the input passed to the FREELOAD instruction.

\item $dest$ is the input passed to the JMP or the conditioned JMP instructions.
\end{enumerate}
\end{itemize}
\end{frame}







\begin{frame}[allowframebreaks]{How to Encode the Move State Machine}
\begin{itemize}
\item Let's now explain how to encode the instructions included in the program:
\begin{align*}
\mathbf{MOV}~A, 10 \quad \mathbf{MOV}~B, 3 \quad \mathbf{JMP}~2 \quad \mathbf{JMP}~(if~B = 0)~6 \quad \mathbf{MUL}~A, A \quad \mathbf{DEC}~B \quad \mathbf{STOP}
\end{align*}
\end{itemize}
\small
%TODO: Add dest and FREE
\[
\begin{array}{|c|c|}
\hline
\multicolumn{2}{|c|}{\mathbf{Instruction}} \\ \hline
\mathbf{MOV} & A, 10 \\ \hline
\mathbf{MOV} & B, 3 \\ \hline
\mathbf{JMP} & 2 \\ \hline
\mathbf{JMPC} & 6 \\ \hline
\mathbf{MULT} & A, A \\ \hline
\mathbf{DEC} & B \\ \hline
\mathbf{STOP} & \emptyset \\ \hline
\end{array}
\hspace{0.1cm}
\begin{array}{|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{inA} & \textbf{inB} & \textbf{dec} & \textbf{inFREE} & \textbf{setA} & \textbf{setB} & \textbf{isJMP} & \textbf{isJMPC} & \textbf{isMULT} \\ \hline
0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\ \hline
0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 \\ \hline
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ \hline
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
\end{array}
\hspace{0.1cm}
\begin{array}{|c|}
\hline
\mathbf{Inst.~Value} \\ \hline
xxx \\ \hline
xxx \\ \hline
xxx \\ \hline
xxx \\ \hline
xxx \\ \hline
xxx \\ \hline
xxx \\ \hline
\end{array}
\]

\normalsize
\begin{itemize}
\item We code the instruction value as follows:
\[
\mathsf{inst} = ~\inp A + 2 \cdot \inp B + 2^2 \cdot \inp FREE + 2^3 \cdot \set A + 2^4 \cdot \set B.
\]

\item We can write the previous table values as the following polynomial identity:
\begin{align*}
\mathsf{inst}(x) = &~\inp A(x) + 2 \cdot \inp B(x) + 2^2 \cdot \inp C(x) + 2^3 \cdot \inp D(x) + 2^4 \cdot \inp E(x) \\
& + 2^5 \cdot \set A(x) + 2^6 \cdot \set B(x) + 2^7 \cdot \set C(x) + 2^8 \cdot \set D(x) + 2^9 \cdot \set E(x).
\end{align*}

\item Now, to build a program, every instruction will be uniquely identified by its value and the position in which it is executed.
\item We define the polynomial $\mathsf{rom}(x)$ which consists on an instruction value concatenated with its position:
\[
\begin{array}{|c|c|c|c|}
\hline
\mathbf{Position} & \mathbf{Instruction} & \mathbf{Inst.~Value} & \mathbf{Rom} = \mathbf{inst} + 2^{16} \cdot \mathbf{position} \\ \hline
0 & \mathbf{MOV} \quad B, A & 0x0041 & 0x00041 \\ \hline
1 & \mathbf{MOV} \quad C, D & 0x0088 & 0x10088 \\ \hline
2 & \mathbf{MOV} \quad A, D & 0x0028 & 0x20028 \\ \hline
3 & \mathbf{MOV} \quad E, B & 0x0202 & 0x30202 \\ \hline
\end{array}
\]
\end{itemize}
\end{frame}


\begin{frame}{Main State Machine of a Simplified Virtual Machine}
\begin{figure}
	\includegraphics[width=0.65\textwidth]{\zkevmdir/architecture/figures/main-state-machine-simplified-overview}
\end{figure}
\end{frame}
















\begin{frame}[allowframebreaks]{Example Program}
\begin{itemize}
\item Let's now work with a real program:
\[
\begin{array}{|c|l|c|}
\hline
\mathbf{Position} & \multicolumn{2}{|c|}{\mathbf{Instruction}} \\ \hline
0 & \mathbf{FREELOAD} & A \\ \hline
1 & \mathbf{MOV} & B, 3 \\ \hline
2 & \mathbf{JMP}~(if~B = 0) & 6 \\ \hline
3 & \mathbf{MUL} & A, A \\ \hline
4 & \mathbf{DEC} & B \\ \hline
5 & \mathbf{JMP} & 2 \\ \hline
6 & \mathbf{STOP} & \emptyset \\ \hline
\end{array}
\]

\item First, we encode each instruction in hexadecimal as follows:
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{align*}
\mathbf{FREELOAD}~A &\to 0x00010000 \\
\mathbf{MOV}~B,n &\to 0x00020000 + n \\
\mathbf{JMP}~(if~B = 0)~n &\to 0x00040000 + n \\
\mathbf{JMP}~n &\to 0x00080000 + n \\
\mathbf{MUL}~A,A &\to 0x00100000 \\
\mathbf{DEC}~B &\to 0x00200000 \\
\mathbf{STOP} &\to 0x00400000 
\end{align*}
\end{column}
\begin{column}{0.5\textwidth}
\[
\begin{array}{|c|l|c|c|}
\hline
\mathbf{Position} & \multicolumn{2}{|c|}{\mathbf{Instruction}} & \mathbf{Inst.~Value}\\ \hline
0 & \mathbf{FREELOAD} & A & 0x00010000 \\ \hline
1 & \mathbf{MOV} & B, 3 & 0x00020003 \\ \hline
2 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 \\ \hline
3 & \mathbf{MUL} & A, A & 0x00100000 \\ \hline
4 & \mathbf{DEC} & B & 0x00200000 \\ \hline
5 & \mathbf{JMP} & 2 & 0x00080002 \\ \hline
6 & \mathbf{STOP} & \emptyset & 0x00400000 \\ \hline
\end{array}
\]
\end{column}
\end{columns}

\framebreak
\item With the support of this encoding, now we can compute the whole trace of the execution of this program:
\end{itemize}
\scriptsize
\[
\begin{array}{|c|l|c|c|c|c|c|c|}
\hline
\mathbf{Position} & \multicolumn{2}{|c|}{\mathbf{Instruction}} & \mathbf{Inst.~Value} & \mathbf{freeLoad} & \mathbf{PC} & \mathbf{A} & \mathbf{B} \\ \hline
0 & \mathbf{FREELOAD} & A & 0x00010000 & 10 & 0 & 0 & 0 \\ \hline
1 & \mathbf{MOV} & B, 3 & 0x00020003 & 0 & 1 & 10 & 0 \\ \hline
2 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 10 & 3 \\ \hline
3 & \mathbf{MUL} & A, A & 0x00100000 & 0 & 3 & 10 & 3 \\ \hline
4 & \mathbf{DEC} & B & 0x00200000 & 0 & 4 & 100 & 3 \\ \hline
5 & \mathbf{JMP} & 2 & 0x00080002 & 0 & 5 & 100 & 2 \\ \hline
6 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 100 & 2 \\ \hline
7 & \mathbf{MUL} & A, A & 0x00100000 & 0 & 3 & 100 & 2 \\ \hline
8 & \mathbf{DEC} & B & 0x00200000 & 0 & 4 & 1000 & 2 \\ \hline
9 & \mathbf{JMP} & 2 & 0x00080002 & 0 & 5 & 1000 & 1 \\ \hline
10 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 1000 & 1 \\ \hline
11 & \mathbf{MUL} & A, A & 0x00100000 & 0 & 3 & 1000 & 1 \\ \hline
12 & \mathbf{DEC} & B & 0x00200000 & 0 & 4 & 10000 & 1 \\ \hline
13 & \mathbf{JMP} & 2 & 0x00080002 & 0 & 5 & 10000 & 0 \\ \hline
14 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 10000 & 0 \\ \hline
15 & \mathbf{STOP} & \emptyset & 0x00400000 & 0 & 6 & 10000 & 0 \\ \hline
\end{array}
\]
\end{frame}





\begin{frame}[allowframebreaks]{Checking the Correct Program Execution}
\begin{itemize}
\item The question that arises now is:
\begin{center}
\textbf{How do we actually verify that we are executing the correct program?}
\end{center}

\item The solution seems obvious: Check that every row of the trace of the execution coincides with some row of the program.

\item Then, the question becomes to:
\begin{center}
\textbf{How do we actually verify that we are executing the correct program \\ in an efficient manner?}
\end{center}

\item We can do it with Plookup!

\framebreak

\item On the one side:
\[
\begin{array}{|c|l|c|c|c|}
\hline
\mathbf{Position} & \multicolumn{2}{|c|}{\mathbf{Instruction}} & \mathbf{Inst.~Value} & \mathbf{Rom} = \mathbf{inst} + 2^{32} \cdot \mathbf{position} \\ \hline
0 & \mathbf{FREELOAD} & A & 0x00010000 & 0x0.00010000 \\ \hline
1 & \mathbf{MOV} & B, 3 & 0x00020003 & 0x1.00020003 \\ \hline
2 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0x2.00040006 \\ \hline
3 & \mathbf{MUL} & A, A & 0x00100000 & 0x3.00100000 \\ \hline
4 & \mathbf{DEC} & B & 0x00200000 & 0x4.00200000 \\ \hline
5 & \mathbf{JMP} & 2 & 0x00080002 & 0x5.00080002 \\ \hline
6 & \mathbf{STOP} & \emptyset & 0x00400000 & 0x6.00400000 \\ \hline
\end{array}
\]

\item On the other side:
\scriptsize
\[
\begin{array}{|c|l|c|c|c|c|c|c|c|}
\hline
\mathbf{Position} & \multicolumn{2}{|c|}{\mathbf{Instruction}} & \mathbf{Inst.~Value} & \mathbf{freeLoad} & \mathbf{PC} & \mathbf{A} & \mathbf{B} &  \mathbf{instTrace} = \mathbf{inst} + 2^{32} \cdot \mathbf{PC} \\ \hline
0 & \mathbf{FREELOAD} & A & 0x00010000 & 10 & 0 & 0 & 0 & 0x0.00010000 \\ \hline
1 & \mathbf{MOV} & B, 3 & 0x00020003 & 0 & 1 & 10 & 0 & 0x1.00020003 \\ \hline
2 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 10 & 3 & 0x2.00040006 \\ \hline
3 & \mathbf{MUL} & A, A & 0x00100000 & 0 & 3 & 10 & 3 & 0x3.00100000 \\ \hline
4 & \mathbf{DEC} & B & 0x00200000 & 0 & 4 & 100 & 3 & 0x4.00200000 \\ \hline
5 & \mathbf{JMP} & 2 & 0x00080002 & 0 & 5 & 100 & 2 & 0x5.00080002 \\ \hline
6 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 100 & 2 & 0x2.00040006 \\ \hline
7 & \mathbf{MUL} & A, A & 0x00100000 & 0 & 3 & 100 & 2 & 0x3.00100000 \\ \hline
8 & \mathbf{DEC} & B & 0x00200000 & 0 & 4 & 1000 & 2 & 0x4.00200000 \\ \hline
9 & \mathbf{JMP} & 2 & 0x00080002 & 0 & 5 & 1000 & 1 & 0x5.00080002 \\ \hline
10 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 1000 & 1 & 0x2.00040006 \\ \hline
11 & \mathbf{MUL} & A, A & 0x00100000 & 0 & 3 & 1000 & 1 & 0x3.00100000 \\ \hline
12 & \mathbf{DEC} & B & 0x00200000 & 0 & 4 & 10000 & 1 & 0x4.00200000 \\ \hline
13 & \mathbf{JMP} & 2 & 0x00080002 & 0 & 5 & 10000 & 0 & 0x5.00080002 \\ \hline
14 & \mathbf{JMP}~(if~B = 0) & 6 & 0x00040006 & 0 & 2 & 10000 & 0 & 0x2.00040006 \\ \hline
15 & \mathbf{STOP} & \emptyset & 0x00400000 & 0 & 6 & 10000 & 0 & 0x6.00400000 \\ \hline
\end{array}
\]

\normalsize
\item So, to check that the correct program is being executed, we simply have to use Plookup to determine if:
\[
\mathbf{instTrace} \subset \mathbf{Rom}
\]

\item In simple words, the trace being executed is an execution of the actual program if the instruction trace is contained in the ROM of the program.
\end{itemize}
\end{frame}